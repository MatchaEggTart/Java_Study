* 第4章 对象与类
	- 面向对象程序设计概述
	- 使用预定义类
	- 用户自定义类
	- 静态域与静态方法
	- 方法参数
	- 对象构造
	- 包
	- 文档注释
	- 类设计技巧

** 4.1 面向对象程序概述
   - OOP(面向对象程序设计)， Java 是完全面向对象的。 万物皆对象(面向对象的程序是由对象组成)。

**** 自构还是外购
     - 自己构造对象， 还是从外界购买对象， 完全取决于 开发项目的 『预算』 『时间』

**** 面向过程、面向对象

     - 面向过程程序设计
       - 这是以算法第一， 数据结构第二 的程序设计思想

     - 面向对象程序设计
       - 这是以数据结构第一， 算法第二 的程序设计思想

**** 特点
     - 面向对象更加适应解决规模较大的问题
     - 面向对象编程 不关心对象的具体实现， 只要能『满足用户需求即可』
     - 也容易从对象找到类的错误， 维护轻松啊


*** 4.1.1 类
    - class

**** instance 实例
     - 由类构造(construct) 对象的过程 称为 『创建类的 实例』。 

**** 类实例
     - 就是对象， 类的实际例子。

**** encapsulation 封装
     - (数据隐藏)， 封装把 数据 和 行为 组合为一个包中， 并对 对象 的使用者隐藏了 数据的『实现方式』

**** instance field 实例域
     - 实例字段? 对象中的  数据 称为 实例域。

**** 实例域值 (实例变量)
     - 每个特定的类实例(对象)都有一组特定的实例域值。 不就是每个对象都有属于自己的实例变量。

**** method 方法
     - 操纵数据的过程 称为 方法。	———————— 不就是函数吗?那么高大上干吗

**** state 状态
     - 方法、 实例域 组合的集合就是对象的当前状态。

**** 如何实现封装
     - 实现封装的关键在于 绝对不能 让类中的方法(静态方法、实例方法) 直接地访问 其他类的 实例域。
     - 程序仅通过对象的方法， 与对象数据进行交互。

**** 如何形容封装
     - 黑盒(别说得那么屌， 这个词我早在C Primer Plus 见过了)

**** extends 扩展
     - 可以『扩展』一个类来建立一个新的类， 新的类， 又构造一堆新的对象， 真的生生不息。
     - 拓展一个类建立一个新的类的行为叫 ———— 『继承』(inheritance)


*** 4.1.2 对象
    - 三大特性

**** (behavior) 行为
     - 可以对对象施加哪些操作(方法)?
***** 
      - 对象的行为 是用可调用的 『方法』 定义的。

**** (state) 状态
     - 当操作(方法)结束后， 对象改变了啥?
***** 
      - 每个对象都保持着描述自己当前特征的信息。 这是对象的状态， 改变状态『不是自发』的， 必须调用方法
      - 如果不调用方法能改变对象状态， 说明封装性遭到破坏

**** (identity) 标识
     - 如何辨别相同行为和状态的不同对象?
***** 
      - 状态不能描述一个对象， 每个对象都有唯一的身份(identity), 每个对象的 『标识』永远不同
      - 状态也常常存在差异。


*** 4.1.3 识别类
    - 面向对象设计 逻辑
      - 优先从 设计类 开始， 然后在类里面添加方法。

**** 识别类的简单规则
     - 在分析问题的过程中寻找名词， 而方法对应动词

**** 例子:
     #+BEGIN_SRC
     <name>				action
     Item		商品		添加
     Order		订单		Item添加到Order
     Shipping address	送货地址		发送
     Payment		付款		支付、取消
     Account		账户		查看余额
     #+END_SRC

**** 创建类
     - 找名词

**** 创建方法
     - 找动词


*** 4.1.4 类之间的关系

**** 常见关系
     - uses-a	依赖
     - has-a	聚合
     - is-a	继承

**** dependence (依赖)
     - 即 "uses-a" 关系。

     - 如果一个类的方法 操纵 另一个类的 对象， 我们就说 一个类依赖于另一个类。
       - ex: 
	 #+BEGIN_SRC 
	 Order(订单)对象需要『访问』Account(账户)对象查看信用状态
	 Order 用方法 操纵 Account对象
	 Order 依赖 Account
	 像 Item 就跟 Account 无依赖
	 #+END_SRC

     - 让类之间的『耦合度』最少
       - 尽可能将 互相依赖的类 减至最少。 因为如果耦合度高， 一个类被修改，可能会导致依赖他的类出bug！
	 - ex:
	   #+BEGIN_SRC java
	   // A 被修改前
	   class A {
	       public static int AandB(int a, int b){
	           return (a > b) ? a : b;
	       }
	   }

	   class B {
	       int a = 2000000;
	       int b = 100000;

	       int c = AandB(a, b);
	   }

	   // A 被修改后
	   class A {
	       public static double AandB(int a, int b){
	           return (double)((a > b) ? a : b);
	       }
	   }
	   // 这样B 肯定报错
	   #+END_SRC

**** aggregation (聚合)
     - 即 "has-a" 关系， 专家喜欢叫『关联』。

     - 一个对象包含一些其他类的对象。(一个 Order类的对象 包含一些 Item对象)。

**** inheritance (继承)
     - 即 "is-a" 关系。 也可以叫『拓展』。

     - 类继承一个类的方法与变量。 A类拓展B类， A类不但包含了 从B类继承的方法， 还会拥有一些功能。

** 4.2 使用预定义类
   - 不是所有类都具有面向对象特征。 ex: Math类。 不必考虑它的方法的具体实现功能， 只要知道方法名、参数就可以(能用就行的意思?)。

*** 4.2.1 对象与对象变量

**** constructor (构造器)

     - What
       - 用来构造新实例(就是模具(类)要造装备(对象)， 需要用构造器)。
       - 本质上 构造器 是一种 『特殊的方法』。
     - 功能
       - 用来构造并『初始化对象』。 (一定初始化的， 除了基础数据)。
     - 特征
       - 与『类名』相同。 至于他屁股的()， 那人家毕竟是个方法嘛！
     - 构造一个某类的对象， 必须在构造器前面添加 new 操作符
       - ex:
	 #+BEGIN_SRC java
	 new Date()
	 #+END_SRC

       - 这个表达式构造了一个『新』对象， 一定会被初始化了的。

       - 构造的对象需要多次使用的话， 就要将对象存放在一个变量中。

     - 没有初始化的『变量』(不是对象)
       - ex:
         #+BEGIN_SRC java
         Date dealine;
         #+END_SRC

       - dealine 可以引用Date类型的对象。 但是， 变量dealine不是一个对象。 实际上，也没有引用对象。

	 - 必须初始化或者引用一个已存在的对象。

	 - 引用对象， 感觉就是抓过来赋值， 还特么时地址值而已。

     - 两个变量可以引用同一对象！
       - 对象变量并没有实际包含一个对象， 仅仅引用一个对象。

       - Java 中， 任何对象的『值』都是对存储在另外一个地方的一个对象的引用。

       - 所以对象变量可以引用null！

     - C++注释
       - ex:
	 #+BEGIN_SRC C++
	 Date birthday;		// Java
	 			// 可以理解为对象指针
	 Date * birthday;	// C++
	 #+END_SRC

     - Java的对象存储在哪？
       - 所有对象都存在堆中。

*** 4.2.2 Java 类库中的 LocalDate类

- 首先
